// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

package provider

import (
	"encoding/json"
	"github.com/antonbabenko/terraform-provider-openai/v2/internal/sdk/pkg/models/shared"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"math/big"
)

func (r *CompletionResourceModel) ToCreateSDKType() *shared.CreateCompletionRequest {
	bestOf := new(int64)
	if !r.BestOf.IsUnknown() && !r.BestOf.IsNull() {
		*bestOf = r.BestOf.ValueInt64()
	} else {
		bestOf = nil
	}
	echo := new(bool)
	if !r.Echo.IsUnknown() && !r.Echo.IsNull() {
		*echo = r.Echo.ValueBool()
	} else {
		echo = nil
	}
	frequencyPenalty := new(float64)
	if !r.FrequencyPenalty.IsUnknown() && !r.FrequencyPenalty.IsNull() {
		*frequencyPenalty, _ = r.FrequencyPenalty.ValueBigFloat().Float64()
	} else {
		frequencyPenalty = nil
	}
	logitBias := make(map[string]int64)
	for logitBiasKey, logitBiasValue := range r.LogitBias {
		logitBiasInst := logitBiasValue.ValueInt64()
		logitBias[logitBiasKey] = logitBiasInst
	}
	logprobs := new(int64)
	if !r.Logprobs.IsUnknown() && !r.Logprobs.IsNull() {
		*logprobs = r.Logprobs.ValueInt64()
	} else {
		logprobs = nil
	}
	maxTokens := new(int64)
	if !r.MaxTokens.IsUnknown() && !r.MaxTokens.IsNull() {
		*maxTokens = r.MaxTokens.ValueInt64()
	} else {
		maxTokens = nil
	}
	model := shared.CreateCompletionRequestModel(r.Model.ValueString())
	n := new(int64)
	if !r.N.IsUnknown() && !r.N.IsNull() {
		*n = r.N.ValueInt64()
	} else {
		n = nil
	}
	presencePenalty := new(float64)
	if !r.PresencePenalty.IsUnknown() && !r.PresencePenalty.IsNull() {
		*presencePenalty, _ = r.PresencePenalty.ValueBigFloat().Float64()
	} else {
		presencePenalty = nil
	}
	var prompt *shared.Prompt
	if r.Prompt != nil {
		str := new(string)
		if !r.Prompt.Str.IsUnknown() && !r.Prompt.Str.IsNull() {
			*str = r.Prompt.Str.ValueString()
		} else {
			str = nil
		}
		if str != nil {
			prompt = &shared.Prompt{
				Str: str,
			}
		}
		var arrayOfstr []string = nil
		for _, arrayOfstrItem := range r.Prompt.ArrayOfstr {
			arrayOfstr = append(arrayOfstr, arrayOfstrItem.ValueString())
		}
		if arrayOfstr != nil {
			prompt = &shared.Prompt{
				ArrayOfstr: arrayOfstr,
			}
		}
		var arrayOfInteger []int64 = nil
		for _, arrayOfIntegerItem := range r.Prompt.ArrayOfInteger {
			arrayOfInteger = append(arrayOfInteger, arrayOfIntegerItem.ValueInt64())
		}
		if arrayOfInteger != nil {
			prompt = &shared.Prompt{
				ArrayOfInteger: arrayOfInteger,
			}
		}
		var arrayOfArrayOfInteger [][]int64 = nil
		for _, arrayOfArrayOfIntegerItem := range r.Prompt.ArrayOfArrayOfInteger {
			var arrayOfArrayOfIntegerTmp []int64 = nil
			for _, item := range arrayOfArrayOfIntegerItem {
				arrayOfArrayOfIntegerTmp = append(arrayOfArrayOfIntegerTmp, item.ValueInt64())
			}
			arrayOfArrayOfInteger = append(arrayOfArrayOfInteger, arrayOfArrayOfIntegerTmp)
		}
		if arrayOfArrayOfInteger != nil {
			prompt = &shared.Prompt{
				ArrayOfArrayOfInteger: arrayOfArrayOfInteger,
			}
		}
	}
	var stop *shared.CreateCompletionRequestStop
	if r.Stop != nil {
		str1 := new(string)
		if !r.Stop.Str.IsUnknown() && !r.Stop.Str.IsNull() {
			*str1 = r.Stop.Str.ValueString()
		} else {
			str1 = nil
		}
		if str1 != nil {
			stop = &shared.CreateCompletionRequestStop{
				Str: str1,
			}
		}
		var arrayOfstr1 []string = nil
		for _, arrayOfstrItem1 := range r.Stop.ArrayOfstr {
			arrayOfstr1 = append(arrayOfstr1, arrayOfstrItem1.ValueString())
		}
		if arrayOfstr1 != nil {
			stop = &shared.CreateCompletionRequestStop{
				ArrayOfstr: arrayOfstr1,
			}
		}
	}
	stream := new(bool)
	if !r.Stream.IsUnknown() && !r.Stream.IsNull() {
		*stream = r.Stream.ValueBool()
	} else {
		stream = nil
	}
	suffix := new(string)
	if !r.Suffix.IsUnknown() && !r.Suffix.IsNull() {
		*suffix = r.Suffix.ValueString()
	} else {
		suffix = nil
	}
	temperature := new(float64)
	if !r.Temperature.IsUnknown() && !r.Temperature.IsNull() {
		*temperature, _ = r.Temperature.ValueBigFloat().Float64()
	} else {
		temperature = nil
	}
	topP := new(float64)
	if !r.TopP.IsUnknown() && !r.TopP.IsNull() {
		*topP, _ = r.TopP.ValueBigFloat().Float64()
	} else {
		topP = nil
	}
	user := new(string)
	if !r.User.IsUnknown() && !r.User.IsNull() {
		*user = r.User.ValueString()
	} else {
		user = nil
	}
	out := shared.CreateCompletionRequest{
		BestOf:           bestOf,
		Echo:             echo,
		FrequencyPenalty: frequencyPenalty,
		LogitBias:        logitBias,
		Logprobs:         logprobs,
		MaxTokens:        maxTokens,
		Model:            model,
		N:                n,
		PresencePenalty:  presencePenalty,
		Prompt:           prompt,
		Stop:             stop,
		Stream:           stream,
		Suffix:           suffix,
		Temperature:      temperature,
		TopP:             topP,
		User:             user,
	}
	return &out
}

func (r *CompletionResourceModel) RefreshFromCreateResponse(resp *shared.CreateCompletionResponse) {
	if len(r.Choices) > len(resp.Choices) {
		r.Choices = r.Choices[:len(resp.Choices)]
	}
	for choicesCount, choicesItem := range resp.Choices {
		var choices1 CreateCompletionResponseChoices
		choices1.FinishReason = types.StringValue(string(choicesItem.FinishReason))
		choices1.Index = types.Int64Value(choicesItem.Index)
		if choicesItem.Logprobs == nil {
			choices1.Logprobs = nil
		} else {
			choices1.Logprobs = &Logprobs{}
			choices1.Logprobs.TextOffset = nil
			for _, v := range choicesItem.Logprobs.TextOffset {
				choices1.Logprobs.TextOffset = append(choices1.Logprobs.TextOffset, types.Int64Value(v))
			}
			choices1.Logprobs.TokenLogprobs = nil
			for _, v := range choicesItem.Logprobs.TokenLogprobs {
				choices1.Logprobs.TokenLogprobs = append(choices1.Logprobs.TokenLogprobs, types.NumberValue(big.NewFloat(float64(v))))
			}
			choices1.Logprobs.Tokens = nil
			for _, v := range choicesItem.Logprobs.Tokens {
				choices1.Logprobs.Tokens = append(choices1.Logprobs.Tokens, types.StringValue(v))
			}
			if choicesItem.Logprobs.TopLogprobs == nil {
				choices1.Logprobs.TopLogprobs = types.StringNull()
			} else {
				topLogprobsResult, _ := json.Marshal(choicesItem.Logprobs.TopLogprobs)
				choices1.Logprobs.TopLogprobs = types.StringValue(string(topLogprobsResult))
			}
		}
		choices1.Text = types.StringValue(choicesItem.Text)
		if choicesCount+1 > len(r.Choices) {
			r.Choices = append(r.Choices, choices1)
		} else {
			r.Choices[choicesCount].FinishReason = choices1.FinishReason
			r.Choices[choicesCount].Index = choices1.Index
			r.Choices[choicesCount].Logprobs = choices1.Logprobs
			r.Choices[choicesCount].Text = choices1.Text
		}
	}
	r.Created = types.Int64Value(resp.Created)
	r.ID = types.StringValue(resp.ID)
	r.Model = types.StringValue(string(resp.Model))
	r.Object = types.StringValue(resp.Object)
	if resp.Usage == nil {
		r.Usage = nil
	} else {
		r.Usage = &Usage{}
		r.Usage.CompletionTokens = types.Int64Value(resp.Usage.CompletionTokens)
		r.Usage.PromptTokens = types.Int64Value(resp.Usage.PromptTokens)
		r.Usage.TotalTokens = types.Int64Value(resp.Usage.TotalTokens)
	}
}
