// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package provider

import (
	"encoding/json"
	tfTypes "github.com/antonbabenko/terraform-provider-openai/v2/internal/provider/types"
	"github.com/antonbabenko/terraform-provider-openai/v2/internal/sdk/models/shared"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

func (r *ChatCompletionResourceModel) ToSharedCreateChatCompletionRequest() *shared.CreateChatCompletionRequest {
	frequencyPenalty := new(float64)
	if !r.FrequencyPenalty.IsUnknown() && !r.FrequencyPenalty.IsNull() {
		*frequencyPenalty, _ = r.FrequencyPenalty.ValueBigFloat().Float64()
	} else {
		frequencyPenalty = nil
	}
	var functionCall *shared.CreateChatCompletionRequestFunctionCall
	if r.FunctionCall != nil {
		one := new(shared.One)
		if !r.FunctionCall.One.IsUnknown() && !r.FunctionCall.One.IsNull() {
			*one = shared.One(r.FunctionCall.One.ValueString())
		} else {
			one = nil
		}
		if one != nil {
			functionCall = &shared.CreateChatCompletionRequestFunctionCall{
				One: one,
			}
		}
		var two *shared.Two
		if r.FunctionCall.Two != nil {
			var name string
			name = r.FunctionCall.Two.Name.ValueString()

			two = &shared.Two{
				Name: name,
			}
		}
		if two != nil {
			functionCall = &shared.CreateChatCompletionRequestFunctionCall{
				Two: two,
			}
		}
	}
	var functions []shared.ChatCompletionFunctions = []shared.ChatCompletionFunctions{}
	for _, functionsItem := range r.Functions {
		description := new(string)
		if !functionsItem.Description.IsUnknown() && !functionsItem.Description.IsNull() {
			*description = functionsItem.Description.ValueString()
		} else {
			description = nil
		}
		var name1 string
		name1 = functionsItem.Name.ValueString()

		parameters := make(map[string]interface{})
		for parametersKey, parametersValue := range functionsItem.Parameters {
			var parametersInst interface{}
			_ = json.Unmarshal([]byte(parametersValue.ValueString()), &parametersInst)
			parameters[parametersKey] = parametersInst
		}
		functions = append(functions, shared.ChatCompletionFunctions{
			Description: description,
			Name:        name1,
			Parameters:  parameters,
		})
	}
	logitBias := make(map[string]int64)
	for logitBiasKey, logitBiasValue := range r.LogitBias {
		var logitBiasInst int64
		logitBiasInst = logitBiasValue.ValueInt64()

		logitBias[logitBiasKey] = logitBiasInst
	}
	maxTokens := new(int64)
	if !r.MaxTokens.IsUnknown() && !r.MaxTokens.IsNull() {
		*maxTokens = r.MaxTokens.ValueInt64()
	} else {
		maxTokens = nil
	}
	var messages []shared.ChatCompletionRequestMessage = []shared.ChatCompletionRequestMessage{}
	for _, messagesItem := range r.Messages {
		content := new(string)
		if !messagesItem.Content.IsUnknown() && !messagesItem.Content.IsNull() {
			*content = messagesItem.Content.ValueString()
		} else {
			content = nil
		}
		var functionCall1 *shared.FunctionCall
		if messagesItem.FunctionCall != nil {
			var arguments string
			arguments = messagesItem.FunctionCall.Arguments.ValueString()

			var name2 string
			name2 = messagesItem.FunctionCall.Name.ValueString()

			functionCall1 = &shared.FunctionCall{
				Arguments: arguments,
				Name:      name2,
			}
		}
		name3 := new(string)
		if !messagesItem.Name.IsUnknown() && !messagesItem.Name.IsNull() {
			*name3 = messagesItem.Name.ValueString()
		} else {
			name3 = nil
		}
		role := shared.Role(messagesItem.Role.ValueString())
		messages = append(messages, shared.ChatCompletionRequestMessage{
			Content:      content,
			FunctionCall: functionCall1,
			Name:         name3,
			Role:         role,
		})
	}
	model := shared.CreateChatCompletionRequestModel(r.Model.ValueString())
	n := new(int64)
	if !r.N.IsUnknown() && !r.N.IsNull() {
		*n = r.N.ValueInt64()
	} else {
		n = nil
	}
	presencePenalty := new(float64)
	if !r.PresencePenalty.IsUnknown() && !r.PresencePenalty.IsNull() {
		*presencePenalty, _ = r.PresencePenalty.ValueBigFloat().Float64()
	} else {
		presencePenalty = nil
	}
	var stop *shared.Stop
	if r.Stop != nil {
		str := new(string)
		if !r.Stop.Str.IsUnknown() && !r.Stop.Str.IsNull() {
			*str = r.Stop.Str.ValueString()
		} else {
			str = nil
		}
		if str != nil {
			stop = &shared.Stop{
				Str: str,
			}
		}
		var arrayOfStr []string = []string{}
		for _, arrayOfStrItem := range r.Stop.ArrayOfStr {
			arrayOfStr = append(arrayOfStr, arrayOfStrItem.ValueString())
		}
		if arrayOfStr != nil {
			stop = &shared.Stop{
				ArrayOfStr: arrayOfStr,
			}
		}
	}
	stream := new(bool)
	if !r.Stream.IsUnknown() && !r.Stream.IsNull() {
		*stream = r.Stream.ValueBool()
	} else {
		stream = nil
	}
	temperature := new(float64)
	if !r.Temperature.IsUnknown() && !r.Temperature.IsNull() {
		*temperature, _ = r.Temperature.ValueBigFloat().Float64()
	} else {
		temperature = nil
	}
	topP := new(float64)
	if !r.TopP.IsUnknown() && !r.TopP.IsNull() {
		*topP, _ = r.TopP.ValueBigFloat().Float64()
	} else {
		topP = nil
	}
	user := new(string)
	if !r.User.IsUnknown() && !r.User.IsNull() {
		*user = r.User.ValueString()
	} else {
		user = nil
	}
	out := shared.CreateChatCompletionRequest{
		FrequencyPenalty: frequencyPenalty,
		FunctionCall:     functionCall,
		Functions:        functions,
		LogitBias:        logitBias,
		MaxTokens:        maxTokens,
		Messages:         messages,
		Model:            model,
		N:                n,
		PresencePenalty:  presencePenalty,
		Stop:             stop,
		Stream:           stream,
		Temperature:      temperature,
		TopP:             topP,
		User:             user,
	}
	return &out
}

func (r *ChatCompletionResourceModel) RefreshFromSharedCreateChatCompletionResponse(resp *shared.CreateChatCompletionResponse) {
	if resp != nil {
		r.Choices = []tfTypes.Choices{}
		if len(r.Choices) > len(resp.Choices) {
			r.Choices = r.Choices[:len(resp.Choices)]
		}
		for choicesCount, choicesItem := range resp.Choices {
			var choices1 tfTypes.Choices
			choices1.FinishReason = types.StringValue(string(choicesItem.FinishReason))
			choices1.Index = types.Int64Value(choicesItem.Index)
			choices1.Message.Content = types.StringPointerValue(choicesItem.Message.Content)
			if choicesItem.Message.FunctionCall == nil {
				choices1.Message.FunctionCall = nil
			} else {
				choices1.Message.FunctionCall = &tfTypes.ChatCompletionResponseMessageFunctionCall{}
				choices1.Message.FunctionCall.Arguments = types.StringPointerValue(choicesItem.Message.FunctionCall.Arguments)
				choices1.Message.FunctionCall.Name = types.StringPointerValue(choicesItem.Message.FunctionCall.Name)
			}
			choices1.Message.Role = types.StringValue(string(choicesItem.Message.Role))
			if choicesCount+1 > len(r.Choices) {
				r.Choices = append(r.Choices, choices1)
			} else {
				r.Choices[choicesCount].FinishReason = choices1.FinishReason
				r.Choices[choicesCount].Index = choices1.Index
				r.Choices[choicesCount].Message = choices1.Message
			}
		}
		r.Created = types.Int64Value(resp.Created)
		r.ID = types.StringValue(resp.ID)
		r.Model = types.StringValue(string(resp.Model))
		r.Object = types.StringValue(resp.Object)
		if resp.Usage == nil {
			r.Usage = nil
		} else {
			r.Usage = &tfTypes.Usage{}
			r.Usage.CompletionTokens = types.Int64Value(resp.Usage.CompletionTokens)
			r.Usage.PromptTokens = types.Int64Value(resp.Usage.PromptTokens)
			r.Usage.TotalTokens = types.Int64Value(resp.Usage.TotalTokens)
		}
	}
}
